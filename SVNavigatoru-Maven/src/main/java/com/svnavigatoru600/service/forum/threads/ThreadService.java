package com.svnavigatoru600.service.forum.threads;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;

import org.springframework.context.MessageSource;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;

import com.svnavigatoru600.domain.forum.Thread;
import com.svnavigatoru600.repository.forum.ThreadDao;
import com.svnavigatoru600.service.util.Localization;

/**
 * Provides convenient methods to work with {@link com.svnavigatoru600.domain.forum.Thread Thread} objects.
 * <p>
 * For instance: There are methods which determine whether the currently logged-in user has rights to
 * manipulate with a particular {@link com.svnavigatoru600.domain.forum.Thread Thread}.
 * 
 * @author <a href="mailto:skalicky.tomas@gmail.com">Tomas Skalicky</a>
 */
@Service
public class ThreadService {

    /**
     * The object which provides a persistence.
     */
    private final ThreadDao threadDao;

    /**
     * Constructor.
     */
    @Inject
    public ThreadService(ThreadDao threadDao) {
        this.threadDao = threadDao;
    }

    @PreAuthorize("hasPermission(#threadId, 'com.svnavigatoru600.domain.forum.Thread', 'edit')")
    public void canEdit(int threadId) {
    }

    @PreAuthorize("hasPermission(#threadId, 'com.svnavigatoru600.domain.forum.Thread', 'delete')")
    public void canDelete(int threadId) {
    }

    /**
     * Returns a {@link Thread} stored in the repository which has the given ID.
     */
    public Thread findById(int threadId) {
        return this.threadDao.findById(threadId);
    }

    /**
     * Returns all {@link Thread Threads} stored in the repository.
     */
    public List<Thread> loadAll() {
        return this.threadDao.loadAll();
    }

    /**
     * Updates the given {@link Thread} in the repository. The old version of this thread should be already
     * stored there.
     */
    public void update(Thread thread) {
        this.threadDao.update(thread);
    }

    /**
     * Updates properties of the given <code>threadToUpdate</code> and persists this {@link Thread} into the
     * repository. The old version of this thread should be already stored there.
     * 
     * @param threadToUpdate
     *            The persisted {@link Thread}
     * @param newThread
     *            The {@link Thread} which contains new values of properties of <code>threadToUpdate</code>.
     *            These values are copied to the persisted thread.
     */
    public void update(Thread threadToUpdate, Thread newThread) {
        threadToUpdate.setName(newThread.getName());
        this.update(threadToUpdate);
    }

    /**
     * Stores the given {@link Thread} to the repository.
     * 
     * @return The new ID of the given {@link Thread} generated by the repository
     */
    public int save(Thread thread) {
        return this.threadDao.save(thread);
    }

    /**
     * Deletes the given {@link Thread} from the repository.
     */
    public void delete(Thread thread) {
        this.threadDao.delete(thread);
    }

    /**
     * Gets a {@link Map} which for each input {@link Thread} contains an appropriate localized delete
     * questions.
     */
    public Map<Thread, String> getLocalizedDeleteQuestions(final List<Thread> threads,
            final HttpServletRequest request, final MessageSource messageSource) {
        final String messageCode = "forum.threads.do-you-really-want-to-delete-thread";
        final Map<Thread, String> questions = new HashMap<Thread, String>();

        for (Thread thread : threads) {
            final Object[] messageParams = new Object[] { thread.getName() };
            questions.put(thread,
                    Localization.findLocaleMessage(messageSource, request, messageCode, messageParams));
        }
        return questions;
    }
}
